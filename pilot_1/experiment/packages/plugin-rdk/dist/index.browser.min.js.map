{"version":3,"file":"index.browser.min.js","sources":["../src/index.ts"],"sourcesContent":["import { JsPsych, JsPsychPlugin, ParameterType, TrialType } from \"jspsych\";\n\nconst info = <const>{\n  name: \"rdk\",\n  parameters: {\n    /** Array containing the valid key(s) that the subject can press to indicate a response. */\n    choices: {\n      type: ParameterType.KEYS,\n      pretty_name: \"Choices\",\n      default: \"ALL_KEYS\",\n    },\n    /** Array containing the correct key(s) for that trial. */\n    correct_choice: {\n      type: ParameterType.KEYS,\n      pretty_name: \"Correct choice\",\n      default: undefined,\n    },\n    /** The length of stimulus presentation. */\n    trial_duration: {\n      type: ParameterType.INT,\n      pretty_name: \"Trial duration\",\n      default: 500,\n    },\n    /** If true, then any valid key will end the trial. */\n    response_ends_trial: {\n      type: ParameterType.BOOL,\n      pretty_name: \"Response ends trial\",\n      default: true,\n    },\n    /** The number of RDK apertures (If more than one, make sure to separate them by setting aperture_center_x and aperture_center_y for each RDK). */\n    number_of_apertures: {\n      type: ParameterType.INT,\n      pretty_name: \"Number of apertures\",\n      default: 1,\n    },\n    /** The number of dots per set in the stimulus. */\n    number_of_dots: {\n      type: ParameterType.INT,\n      pretty_name: \"Number of dots\",\n      default: 300,\n    },\n    /** The number of sets of dots to cycle through. */\n    number_of_sets: {\n      type: ParameterType.INT,\n      pretty_name: \"Number of sets\",\n      default: 1,\n    },\n    /** The direction of coherent motion in degrees. */\n    coherent_direction: {\n      type: ParameterType.INT,\n      pretty_name: \"Coherent direction\",\n      default: 0,\n    },\n    /** The proportion of dots moving in the coherent direction. */\n    coherence: {\n      type: ParameterType.FLOAT,\n      pretty_name: \"Coherence\",\n      default: 0.5,\n    },\n    /** The proportion of dots moving in the direction opposite of the coherent direction. */\n    opposite_coherence: {\n      type: ParameterType.FLOAT,\n      pretty_name: \"Opposite coherence\",\n      default: 0,\n    },\n    /** The radius of the dots in pixels */\n    dot_radius: {\n      type: ParameterType.INT,\n      pretty_name: \"Dot radius\",\n      default: 2,\n    },\n    /** The length of the side of a dot in pixels (only when dot_shape is \"square\") */\n    dot_side_length: {\n      type: ParameterType.INT,\n      pretty_name: \"Dot side length\",\n      default: 1,\n    },\n    /** The number of frames that pass before each dot disappears and reappears somewhere else. */\n    dot_life: {\n      type: ParameterType.INT,\n      pretty_name: \"Dot life\",\n      default: -1,\n    },\n    /** The distance in pixels each dot moves per frame. */\n    move_distance: {\n      type: ParameterType.INT,\n      pretty_name: \"Move distance\",\n      default: 1,\n    },\n    /** The width of the aperture in pixels. */\n    aperture_width: {\n      type: ParameterType.INT,\n      pretty_name: \"Aperture width\",\n      default: 600,\n    },\n    /** The height of the aperture in pixels. */\n    aperture_height: {\n      type: ParameterType.INT,\n      pretty_name: \"Aperture height\",\n      default: 400,\n    },\n    /** The color of the dots. */\n    dot_color: {\n      type: ParameterType.STRING,\n      pretty_name: \"Dot color\",\n      default: \"white\",\n    },\n    /** The shape of the dots */\n    dot_shape: {\n      type: ParameterType.STRING,\n      pretty_name: \"Dot shape\",\n      default: \"circle\",\n    },\n    /** The background color of the stimulus. */\n    background_color: {\n      type: ParameterType.STRING,\n      pretty_name: \"Background color\",\n      default: \"gray\",\n    },\n    /** The type of RDK (refer to documentation for details). */\n    RDK_type: {\n      type: ParameterType.INT,\n      pretty_name: \"RDK type\",\n      default: 3,\n    },\n    /** The shape of the aperture. */\n    aperture_type: {\n      type: ParameterType.INT,\n      pretty_name: \"Aperture Type\",\n      default: 2,\n    },\n    /** The reinsertion rule for dots that move out of the aperture. */\n    reinsert_type: {\n      type: ParameterType.INT,\n      pretty_name: \"Reinsert type\",\n      default: 2,\n    },\n    /** The x-coordinate of the center of the aperture. */\n    aperture_center_x: {\n      type: ParameterType.INT,\n      pretty_name: \"Aperture center X\",\n      default: window.innerWidth / 2,\n    },\n    /** The y-coordinate of the center of the aperture. */\n    aperture_center_y: {\n      type: ParameterType.INT,\n      pretty_name: \"Aperture center Y\",\n      default: window.innerHeight / 2,\n    },\n    /** If true, then a fixation cross will be present in the middle of the screen. */\n    fixation_cross: {\n      type: ParameterType.BOOL,\n      pretty_name: \"Fixation cross\",\n      default: false,\n    },\n    /** The width of the fixation cross in pixels. */\n    fixation_cross_width: {\n      type: ParameterType.INT,\n      pretty_name: \"Fixation cross width\",\n      default: 20,\n    },\n    /** The height of the fixation cross in pixels. */\n    fixation_cross_height: {\n      type: ParameterType.INT,\n      pretty_name: \"Fixation cross height\",\n      default: 20,\n    },\n    /** The color of the fixation cross. */\n    fixation_cross_color: {\n      type: ParameterType.STRING,\n      pretty_name: \"Fixation cross color\",\n      default: \"black\",\n    },\n    /** The thickness of the fixation cross. */\n    fixation_cross_thickness: {\n      type: ParameterType.INT,\n      pretty_name: \"Fixation cross thickness\",\n      default: 1,\n    },\n    /** The presence of a border around the aperture. */\n    border: {\n      type: ParameterType.BOOL,\n      pretty_name: \"Border\",\n      default: false,\n    },\n    /** The thickness of the border in pixels. */\n    border_thickness: {\n      type: ParameterType.INT,\n      pretty_name: \"Border width\",\n      default: 1,\n    },\n    /** The color of the border. */\n    border_color: {\n      type: ParameterType.STRING,\n      pretty_name: \"Border Color\",\n      default: 1,\n    },\n  },\n};\n\ntype Info = typeof info;\n\n/**\n * **RDK**\n *\n * jsPsych plugin for showing a random-dot kinematogram stimulus and recording a keyboard response\n *\n * @author Sivananda Rajananda\n * @see {@link https://www.jspsych.org/plugins/jspsych-rdk/ RDK plugin documentation on jspsych.org}\n * @copyright\n *\n * This code was created in the Consciousness and Metacognition Lab at UCLA,\n * under the supervision of Brian Odegaard and Hakwan Lau\n *\n * We would appreciate it if you cited this paper when you use the RDK:\n * Rajananda, S., Lau, H. & Odegaard, B., (2018). A Random-Dot Kinematogram for Web-Based Vision Research. Journal of Open Research Software. 6(1), p.6. DOI: [http://doi.org/10.5334/jors.194]\n *\n * ----------------------\n *\n * Copyright (C) 2017  Sivananda Rajananda\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\nclass RdkPlugin implements JsPsychPlugin<Info> {\n  static info = info;\n\n  constructor(private jsPsych: JsPsych) {}\n\n  trial(display_element: HTMLElement, trial: TrialType<Info>) {\n    //--------------------------------------\n    //---------SET PARAMETERS BEGIN---------\n    //--------------------------------------\n\n    //Note on '||' logical operator: If the first option is 'undefined', it evalutes to 'false' and the second option is returned as the assignment\n    // Note: trial properties are now read-only, so these params have all been changed to separate variables here and throughout trial function\n    var choices = assignParameterValue(trial.choices, []);\n    var correct_choice = assignParameterValue(trial.correct_choice, undefined);\n    var trial_duration = assignParameterValue(trial.trial_duration, 500);\n    var response_ends_trial = assignParameterValue(trial.response_ends_trial, true);\n    var number_of_apertures = assignParameterValue(trial.number_of_apertures, 1);\n    var number_of_dots = assignParameterValue(trial.number_of_dots, 300);\n    var number_of_sets = assignParameterValue(trial.number_of_sets, 1);\n    var coherent_direction = assignParameterValue(trial.coherent_direction, 0);\n    var coherence = assignParameterValue(trial.coherence, 0.5);\n    var opposite_coherence = assignParameterValue(trial.opposite_coherence, 0);\n    var dot_radius = assignParameterValue(trial.dot_radius, 2);\n    var dot_side_length = assignParameterValue(trial.dot_side_length, 1);\n    var dot_life = assignParameterValue(trial.dot_life, -1);\n    var move_distance = assignParameterValue(trial.move_distance, 1);\n    var aperture_width = assignParameterValue(trial.aperture_width, 600);\n    var aperture_height = assignParameterValue(trial.aperture_height, 400);\n    var dot_color = assignParameterValue(trial.dot_color, \"white\");\n    var dot_shape = assignParameterValue(trial.dot_shape, \"circle\");\n    var background_color = assignParameterValue(trial.background_color, \"gray\");\n    var RDK_type = assignParameterValue(trial.RDK_type, 3);\n    var aperture_type = assignParameterValue(trial.aperture_type, 2);\n    var reinsert_type = assignParameterValue(trial.reinsert_type, 2);\n    var aperture_center_x = assignParameterValue(trial.aperture_center_x, window.innerWidth / 2);\n    var aperture_center_y = assignParameterValue(trial.aperture_center_y, window.innerHeight / 2);\n    var fixation_cross = assignParameterValue(trial.fixation_cross, false);\n    var fixation_cross_width = assignParameterValue(trial.fixation_cross_width, 20);\n    var fixation_cross_height = assignParameterValue(trial.fixation_cross_height, 20);\n    var fixation_cross_color = assignParameterValue(trial.fixation_cross_color, \"black\");\n    var fixation_cross_thickness = assignParameterValue(trial.fixation_cross_thickness, 1);\n    var border = assignParameterValue(trial.border, false);\n    var border_thickness = assignParameterValue(trial.border_thickness, 1);\n    var border_color = assignParameterValue(trial.border_color, \"black\");\n\n    //For square and circle, set the aperture height == aperture width\n    if (apertureType == 1 || apertureType == 3) {\n      aperture_height = aperture_width;\n    }\n\n    //Convert the parameter variables to those that the code below can use\n\n    var nApertures = number_of_apertures; //The number of apertures\n    var nDots = number_of_dots; //Number of dots per set (equivalent to number of dots per frame)\n    var nSets = number_of_sets; //Number of sets to cycle through per frame\n    var coherentDirection = coherent_direction; //The direction of the coherentDots in degrees. Starts at 3 o'clock and goes counterclockwise (0 == rightwards, 90 == upwards, 180 == leftwards, 270 == downwards), range 0 - 360\n    var coherence = coherence; //Proportion of dots to move together, range from 0 to 1\n    var oppositeCoherence = opposite_coherence; // The coherence for the dots going the opposite direction as the coherent dots\n    var dotRadius = dot_radius; //Radius of each dot in pixels\n    var dotSideLength = dot_side_length; // Length of dot side in pixels (only when dot_shape is \"square\")\n    var dotLife = dot_life; //How many frames a dot will keep following its trajectory before it is redrawn at a random location. -1 denotes infinite life (the dot will only be redrawn if it reaches the end of the aperture).\n    var moveDistance = move_distance; //How many pixels the dots move per frame\n    var apertureWidth = aperture_width; // How many pixels wide the aperture is. For square aperture this will be the both height and width. For circle, this will be the diameter.\n    var apertureHeight = aperture_height; //How many pixels high the aperture is. Only relevant for ellipse and rectangle apertures. For circle and square, this is ignored.\n    var dotColor = dot_color; //Color of the dots\n    var backgroundColor = background_color; //Color of the background\n    var apertureCenterX = aperture_center_x; // The x-coordinate of center of the aperture on the screen, in pixels\n    var apertureCenterY = aperture_center_y; // The y-coordinate of center of the aperture on the screen, in pixels\n\n    /** RDK type parameter\n      ** See Fig. 1 in Scase, Braddick, and Raymond (1996) for a visual depiction of these different signal selection rules and noise types\n\n      -------------------\n      SUMMARY:\n\n      Signal Selection rule:\n      -Same: Each dot is designated to be either a coherent dot (signal) or incoherent dot (noise) and will remain so throughout all frames in the display. Coherent dots will always move in the direction of coherent motion in all frames.\n      -Different: Each dot can be either a coherent dot (signal) or incoherent dot (noise) and will be designated randomly (weighted based on the coherence level) at each frame. Only the dots that are designated to be coherent dots will move in the direction of coherent motion, but only in that frame. In the next frame, each dot will be designated randomly again on whether it is a coherent or incoherent dot.\n\n      Noise Type:\n      -Random position: The incoherent dots appear in a random location in the aperture in each frame\n      -Random walk: The incoherent dots will move in a random direction (designated randomly in each frame) in each frame.\n      -Random direction: Each incoherent dot has its own alternative direction of motion (designated randomly at the beginning of the trial), and moves in that direction in each frame.\n\n      -------------------\n\n      1 - same && random position\n      2 - same && random walk\n      3 - same && random direction\n      4 - different && random position\n      5 - different && random walk\n      6 - different && random direction         */\n\n    var RDK = RDK_type;\n\n    /** \n      Shape of aperture\n      1 - Circle\n      2 - Ellipse\n      3 - Square\n      4 - Rectangle\n      */\n    var apertureType = aperture_type;\n\n    /**\n      Shape of dots\n      \"circle\" (default) or \"square\"\n      */\n    var dotShape = dot_shape;\n\n    /*\n      Out of Bounds Decision\n      How we reinsert a dot that has moved outside the edges of the aperture:\n      1 - Randomly appear anywhere in the aperture\n      2 - Appear on the opposite edge of the aperture (Random if square or rectangle, reflected about origin in circle and ellipse)\n      */\n    var reinsertType = reinsert_type;\n\n    //Fixation Cross Parameters\n    var fixationCross = fixation_cross; //To display or not to display the cross\n    var fixationCrossWidth = fixation_cross_width; //The width of the fixation cross in pixels\n    var fixationCrossHeight = fixation_cross_height; //The height of the fixation cross in pixels\n    var fixationCrossColor = fixation_cross_color; //The color of the fixation cross\n    var fixationCrossThickness = fixation_cross_thickness; //The thickness of the fixation cross, must be positive number above 1\n\n    //Border Parameters\n    var border = border; //To display or not to display the border\n    var borderThickness = border_thickness; //The width of the border in pixels\n    var borderColor = border_color; //The color of the border\n\n    //--------------------------------------\n    //----------SET PARAMETERS END----------\n    //--------------------------------------\n\n    //--------Set up Canvas begin-------\n\n    //Create a canvas element and append it to the DOM\n    var canvas = document.createElement(\"canvas\");\n    display_element.appendChild(canvas);\n\n    //The document body IS 'display_element' (i.e. <body class=\"jspsych-display-element\"> .... </body> )\n    var body = document.getElementsByClassName(\"jspsych-display-element\")[0] as HTMLElement;\n\n    //Save the current settings to be restored later\n    var originalMargin = body.style.margin;\n    var originalPadding = body.style.padding;\n    var originalBackgroundColor = body.style.backgroundColor;\n\n    //Remove the margins and paddings of the display_element\n    body.style.margin = \"0\";\n    body.style.padding = \"0\";\n    body.style.backgroundColor = backgroundColor; //Match the background of the display element to the background color of the canvas so that the removal of the canvas at the end of the trial is not noticed\n\n    //Remove the margins and padding of the canvas\n    canvas.style.margin = \"0\";\n    canvas.style.padding = \"0\";\n    // use absolute positioning in top left corner to get rid of scroll bars\n    canvas.style.position = \"absolute\";\n    canvas.style.top = \"0\";\n    canvas.style.left = \"0\";\n\n    //Get the context of the canvas so that it can be painted on.\n    var ctx = canvas.getContext(\"2d\");\n\n    //Declare variables for width and height, and also set the canvas width and height to the window width and height\n    var canvasWidth = (canvas.width = window.innerWidth);\n    var canvasHeight = (canvas.height = window.innerHeight);\n\n    //Set the canvas background color\n    canvas.style.backgroundColor = backgroundColor;\n\n    //--------Set up Canvas end-------\n\n    //--------RDK variables and function calls begin--------\n\n    //This is the main part of the trial that makes everything run\n\n    //Global variable for the current aperture number\n    var currentApertureNumber;\n\n    //3D Array to hold the dots (1st D is Apertures, 2nd D is Sets, 3rd D is Dots)\n    var dotArray3d = [];\n\n    //Variables for different apertures (initialized in setUpMultipleApertures function below)\n    var nDotsArray;\n    var nSetsArray;\n    var coherentDirectionArray;\n    var coherenceArray;\n    var oppositeCoherenceArray;\n    var dotRadiusArray;\n    var dotSideLengthArray;\n    var dotLifeArray;\n    var moveDistanceArray;\n    var apertureWidthArray;\n    var apertureHeightArray;\n    var dotColorArray;\n    var dotShapeArray;\n    var apertureCenterXArray;\n    var apertureCenterYArray;\n    var RDKArray;\n    var apertureTypeArray;\n    var reinsertTypeArray;\n    var fixationCrossArray;\n    var fixationCrossWidthArray;\n    var fixationCrossHeightArray;\n    var fixationCrossColorArray;\n    var fixationCrossThicknessArray;\n    var borderArray;\n    var borderThicknessArray;\n    var borderColorArray;\n\n    //Set up the variables for the apertures\n    const setUpMultipleApertures = () => {\n      nDotsArray = setParameter(nDots);\n      nSetsArray = setParameter(nSets);\n      coherentDirectionArray = setParameter(coherentDirection);\n      coherenceArray = setParameter(coherence);\n      oppositeCoherenceArray = setParameter(oppositeCoherence);\n      dotRadiusArray = setParameter(dotRadius);\n      dotSideLengthArray = setParameter(dotSideLength);\n      dotLifeArray = setParameter(dotLife);\n      moveDistanceArray = setParameter(moveDistance);\n      apertureWidthArray = setParameter(apertureWidth);\n      apertureHeightArray = setParameter(apertureHeight);\n      dotColorArray = setParameter(dotColor);\n      dotShapeArray = setParameter(dotShape);\n      apertureCenterXArray = setParameter(apertureCenterX);\n      apertureCenterYArray = setParameter(apertureCenterY);\n      RDKArray = setParameter(RDK);\n      apertureTypeArray = setParameter(apertureType);\n      reinsertTypeArray = setParameter(reinsertType);\n      fixationCrossArray = setParameter(fixationCross);\n      fixationCrossWidthArray = setParameter(fixationCrossWidth);\n      fixationCrossHeightArray = setParameter(fixationCrossHeight);\n      fixationCrossColorArray = setParameter(fixationCrossColor);\n      fixationCrossThicknessArray = setParameter(fixationCrossThickness);\n      borderArray = setParameter(border);\n      borderThicknessArray = setParameter(borderThickness);\n      borderColorArray = setParameter(borderColor);\n\n      currentSetArray = setParameter(0); //Always starts at zero\n\n      //Loop through the number of apertures to make the dots\n      for (currentApertureNumber = 0; currentApertureNumber < nApertures; currentApertureNumber++) {\n        //Initialize the parameters to make the 2d dot array (one for each aperture);\n        initializeCurrentApertureParameters(currentApertureNumber);\n\n        //Make each 2d array and push it into the 3d array\n        dotArray3d.push(makeDotArray2d());\n      }\n    };\n\n    // Set up multiple apertures\n    setUpMultipleApertures();\n\n    //Declare aperture parameters for initialization based on shape (used in initializeApertureDimensions function below)\n    var horizontalAxis;\n    var verticalAxis;\n\n    //Calculate the x and y jump sizes for coherent dots\n    var coherentJumpSizeX;\n    var coherentJumpSizeY;\n\n    //Calculate the number of coherent, opposite coherent, and incoherent dots\n    var nCoherentDots;\n    var nOppositeCoherentDots;\n    var nIncoherentDots;\n\n    //Make the array of arrays containing dot objects\n    var dotArray2d;\n\n    var dotArray; //Declare a global variable to hold the current array\n    var currentSetArray; //Declare and initialize a global variable to cycle through the dot arrays\n\n    //Initialize stopping condition for animateDotMotion function that runs in a loop\n    var stopDotMotion = false;\n\n    //Variable to control the frame rate, to ensure that the first frame is skipped because it follows a different timing\n    var firstFrame = true; //Used to skip the first frame in animate function below (in animateDotMotion function)\n\n    //Variable to start the timer when the time comes\n    var timerHasStarted = false;\n\n    //Initialize object to store the response data. Default values of -1 are used if the trial times out and the subject has not pressed a valid key\n    var response = {\n      rt: -1,\n      key: \"\",\n    };\n\n    //Declare a global timeout ID to be initialized below in animateDotMotion function and to be used in after_response function\n    var timeoutID;\n\n    //Declare global variable to be defined in startKeyboardListener function and to be used in end_trial function\n    var keyboardListener;\n\n    //Declare global variable to store the frame rate of the trial\n    var frameRate: number | number[] = []; //How often the monitor refreshes, in ms. Currently an array to store all the intervals. Will be converted into a single number (the average) in end_trial function.\n\n    //variable to store how many frames were presented.\n    var numberOfFrames = 0;\n\n    // set up dot-drawing abstractions\n    const pi2 = Math.PI * 2;\n    const circleFn = (x: number, y: number, rad: number) => {\n      ctx.arc(x, y, rad, 0, pi2);\n    };\n    const squareFn = (x: number, y: number, half_len: number) => {\n      const len = half_len * 2;\n      ctx.rect(x - half_len, y - half_len, len, len);\n    };\n\n    //Function to start the keyboard listener\n    const startKeyboardListener = () => {\n      //Start the response listener if there are choices for keys\n      if (choices != \"NO_KEYS\") {\n        //Create the keyboard listener to listen for subjects' key response\n        keyboardListener = this.jsPsych.pluginAPI.getKeyboardResponse({\n          callback_function: after_response, //Function to call once the subject presses a valid key\n          valid_responses: choices, //The keys that will be considered a valid response and cause the callback function to be called\n          rt_method: \"performance\", //The type of method to record timing information.\n          persist: false, //If set to false, keyboard listener will only trigger the first time a valid key is pressed. If set to true, it has to be explicitly cancelled by the cancelKeyboardResponse plugin API.\n          allow_held_key: false, //Only register the key once, after this getKeyboardResponse function is called. (Check JsPsych docs for better info under 'jsPsych.pluginAPI.getKeyboardResponse').\n        });\n      }\n    };\n\n    //Function to end the trial proper\n    const end_trial = () => {\n      //Stop the dot motion animation\n      stopDotMotion = true;\n\n      //Store the number of frames\n      numberOfFrames = (frameRate as number[]).length;\n\n      //Variable to store the frame rate array\n      var frameRateArray = frameRate;\n\n      //Calculate the average frame rate\n      if (numberOfFrames > 0) {\n        //Check to make sure that the array is not empty\n        frameRate =\n          (frameRate as number[]).reduce((total, current) => total + current) / numberOfFrames; //Sum up all the elements in the array\n      } else {\n        frameRate = 0; //Set to zero if the subject presses an answer before a frame is shown (i.e. if frameRate is an empty array)\n      }\n\n      //Kill the keyboard listener if keyboardListener has been defined\n      if (typeof keyboardListener !== \"undefined\") {\n        this.jsPsych.pluginAPI.cancelKeyboardResponse(keyboardListener);\n      }\n\n      //Place all the data to be saved from this trial in one data object\n      var trial_data = {\n        rt: response.rt, //The response time\n        response: response.key, //The key that the subject pressed\n        correct: correctOrNot(), //If the subject response was correct\n        choices: choices, //The set of valid keys\n        correct_choice: correct_choice, //The correct choice(s)\n        trial_duration: trial_duration, //The trial duration\n        response_ends_trial: response_ends_trial, //If the response ends the trial\n        number_of_apertures: number_of_apertures,\n        number_of_dots: number_of_dots,\n        number_of_sets: number_of_sets,\n        coherent_direction: coherent_direction,\n        coherence: coherence,\n        opposite_coherence: opposite_coherence,\n        dot_radius: dot_radius,\n        dot_side_length: dot_side_length,\n        dot_life: dot_life,\n        move_distance: move_distance,\n        aperture_width: aperture_width,\n        aperture_height: aperture_height,\n        dot_color: dot_color,\n        dot_shape: dot_shape,\n        background_color: background_color,\n        RDK_type: RDK_type,\n        aperture_type: aperture_type,\n        reinsert_type: reinsert_type,\n        frame_rate: frameRate, //The average frame rate for the trial\n        frame_rate_array: frameRateArray, //The array of ms per frame in this trial\n        number_of_frames: numberOfFrames, //The number of frames in this trial\n        aperture_center_x: aperture_center_x,\n        aperture_center_y: aperture_center_y,\n        fixation_cross: fixation_cross,\n        fixation_cross_width: fixation_cross_width,\n        fixation_cross_height: fixation_cross_height,\n        fixation_cross_color: fixation_cross_color,\n        fixation_cross_thickness: fixation_cross_thickness,\n        border: border,\n        border_thickness: border_thickness,\n        border_color: border_color,\n        canvas_width: canvasWidth,\n        canvas_height: canvasHeight,\n      };\n\n      //Remove the canvas as the child of the display_element element\n      display_element.innerHTML = \"\";\n\n      //Restore the settings to JsPsych defaults\n      body.style.margin = originalMargin;\n      body.style.padding = originalPadding;\n      body.style.backgroundColor = originalBackgroundColor;\n\n      //End this trial and move on to the next trial\n      this.jsPsych.finishTrial(trial_data);\n    }; //End of end_trial\n\n    //This runs the dot motion simulation, updating it according to the frame refresh rate of the screen.\n    animateDotMotion();\n\n    //--------RDK variables and function calls end--------\n\n    //-------------------------------------\n    //-----------FUNCTIONS BEGIN-----------\n    //-------------------------------------\n\n    //----JsPsych Functions Begin----\n\n    //Function to record the first response by the subject\n    function after_response(info) {\n      //If the response has not been recorded, record it\n      if (response.key == \"\") {\n        response = info; //Replace the response object created above\n      }\n\n      //If the parameter is set such that the response ends the trial, then kill the timeout and end the trial\n      if (response_ends_trial) {\n        window.clearTimeout(timeoutID);\n        end_trial();\n      }\n    } //End of after_response\n\n    //Function that determines if the response is correct\n    const correctOrNot = () => {\n      //Check that the correct_choice has been defined and that it is an array\n      if (typeof correct_choice !== \"undefined\" && correct_choice.constructor === Array) {\n        if (typeof correct_choice[0] === \"string\" || correct_choice[0] instanceof String) {\n          var key_in_choices = correct_choice.every((x: string) => {\n            return this.jsPsych.pluginAPI.compareKeys(x, response.key);\n          });\n          return key_in_choices; //If the response is included in the correct_choice array, return true. Else, return false.\n        } else if (typeof correct_choice[0] === \"number\") {\n          // the elements are numbers (javascript character codes)\n          console.error(\n            \"Error in RDK plugin: elements in the correct_choice array must be key characters (strings).\"\n          );\n          return false; // added due to TS error: not all code paths return a value\n        } else {\n          console.error(\n            \"Error in RDK plugin: elements in the correct_choice array must be key characters (strings).\"\n          );\n          return false; // added due to TS error: not all code paths return a value\n        }\n      } else {\n        console.error(\n          \"Error in RDK plugin: you must specify an array of key characters for the correct_choice parameter.\"\n        );\n        return false; // added due to TS error: not all code paths return a value\n      }\n    };\n\n    //----JsPsych Functions End----\n\n    //----RDK Functions Begin----\n\n    //Function to set the parameters of the array\n    //@ts-expect-error \"not all code paths return a value\"\n    function setParameter(originalVariable) {\n      //Check if it is an array and its length matches the aperture then return the original array\n      if (originalVariable.constructor === Array && originalVariable.length === nApertures) {\n        return originalVariable;\n      }\n      //Else if it is not an array, we make it an array with duplicate values\n      else if (originalVariable.constructor !== Array) {\n        var tempArray = [];\n\n        //Make a for loop and duplicate the values\n        for (var i = 0; i < nApertures; i++) {\n          tempArray.push(originalVariable);\n        }\n        return tempArray;\n      }\n      //Else if the array is not long enough, then print out that error message\n      else if (originalVariable.constructor === Array && originalVariable.length !== nApertures) {\n        console.error(\n          \"If you have more than one aperture, please ensure that arrays that are passed in as parameters are the same length as the number of apertures. Else you can use a single value without the array\"\n        );\n      }\n      //Else print a generic error\n      else {\n        console.error(\n          \"A parameter is incorrectly set. Please ensure that the nApertures parameter is set to the correct value (if using more than one aperture), and all others parameters are set correctly.\"\n        );\n      }\n    }\n\n    //Function to set the global variables to the current aperture so that the correct dots are updated and drawn\n    function initializeCurrentApertureParameters(currentApertureNumber?) {\n      //Set the global variables to that relevant to the current aperture\n      nDots = nDotsArray[currentApertureNumber];\n      nSets = nSetsArray[currentApertureNumber];\n      coherentDirection = coherentDirectionArray[currentApertureNumber];\n      coherence = coherenceArray[currentApertureNumber];\n      oppositeCoherence = oppositeCoherenceArray[currentApertureNumber];\n      dotRadius = dotRadiusArray[currentApertureNumber];\n      dotSideLength = dotSideLengthArray[currentApertureNumber];\n      dotLife = dotLifeArray[currentApertureNumber];\n      moveDistance = moveDistanceArray[currentApertureNumber];\n      apertureWidth = apertureWidthArray[currentApertureNumber];\n      apertureHeight = apertureHeightArray[currentApertureNumber];\n      dotColor = dotColorArray[currentApertureNumber];\n      dotShape = dotShapeArray[currentApertureNumber];\n      apertureCenterX = apertureCenterXArray[currentApertureNumber];\n      apertureCenterY = apertureCenterYArray[currentApertureNumber];\n      RDK = RDKArray[currentApertureNumber];\n      apertureType = apertureTypeArray[currentApertureNumber];\n      reinsertType = reinsertTypeArray[currentApertureNumber];\n      fixationCross = fixationCrossArray[currentApertureNumber];\n      fixationCrossWidth = fixationCrossWidthArray[currentApertureNumber];\n      fixationCrossHeight = fixationCrossHeightArray[currentApertureNumber];\n      fixationCrossColor = fixationCrossColorArray[currentApertureNumber];\n      fixationCrossThickness = fixationCrossThicknessArray[currentApertureNumber];\n      border = borderArray[currentApertureNumber];\n      borderThickness = borderThicknessArray[currentApertureNumber];\n      borderColor = borderColorArray[currentApertureNumber];\n\n      //Calculate the x and y jump sizes for coherent dots\n      coherentJumpSizeX = calculateCoherentJumpSizeX(coherentDirection);\n      coherentJumpSizeY = calculateCoherentJumpSizeY(coherentDirection);\n\n      //Initialize the aperture parameters\n      initializeApertureDimensions();\n\n      //Calculate the number of coherent, opposite coherent, and incoherent dots\n      nCoherentDots = nDots * coherence;\n      nOppositeCoherentDots = nDots * oppositeCoherence;\n      nIncoherentDots = nDots - (nCoherentDots + nOppositeCoherentDots);\n\n      //If the 3d array has been made, then choose the 2d array and the current set\n      dotArray2d = dotArray3d.length !== 0 ? dotArray3d[currentApertureNumber] : undefined;\n    } // End of initializeCurrentApertureParameters\n\n    //Calculate coherent jump size in the x direction\n    function calculateCoherentJumpSizeX(coherentDirection) {\n      var angleInRadians = (coherentDirection * Math.PI) / 180;\n      return moveDistance * Math.cos(angleInRadians);\n    }\n\n    //Calculate coherent jump size in the y direction\n    function calculateCoherentJumpSizeY(coherentDirection) {\n      var angleInRadians = (-coherentDirection * Math.PI) / 180; //Negative sign because the y-axis is flipped on screen\n      return moveDistance * Math.sin(angleInRadians);\n    }\n\n    //Initialize the parameters for the aperture for further calculation\n    function initializeApertureDimensions() {\n      //For circle and square\n      if (apertureType == 1 || apertureType == 3) {\n        horizontalAxis = verticalAxis = apertureWidth / 2;\n      }\n      //For ellipse and rectangle\n      else if (apertureType == 2 || apertureType == 4) {\n        horizontalAxis = apertureWidth / 2;\n        verticalAxis = apertureHeight / 2;\n      }\n    }\n\n    //Make the 2d array, which is an array of array of dots\n    function makeDotArray2d() {\n      //Declare an array to hold the sets of dot arrays\n      var tempArray = [];\n      //Loop for each set of dot array\n      for (var i = 0; i < nSets; i++) {\n        tempArray.push(makeDotArray()); //Make a dot array and push it into the 2d array\n      }\n      return tempArray;\n    }\n\n    //Make the dot array\n    function makeDotArray() {\n      var tempArray = [];\n      for (var i = 0; i < nDots; i++) {\n        //Initialize a dot to be modified and inserted into the array\n        var dot = {\n          x: 0, //x coordinate\n          y: 0, //y coordinate\n          vx: 0, //coherent x jumpsize (if any)\n          vy: 0, //coherent y jumpsize (if any)\n          vx2: 0, //incoherent (random) x jumpsize (if any)\n          vy2: 0, //incoherent (random) y jumpsize (if any)\n          latestXMove: 0, //Stores the latest x move direction for the dot (to be used in reinsertOnOppositeEdge function below)\n          latestYMove: 0, //Stores the latest y move direction for the dot (to be used in reinsertOnOppositeEdge function below)\n          lifeCount: Math.floor(randomNumberBetween(0, dotLife)), //Counter for the dot's life. Updates every time it is shown in a frame\n          updateType: \"\", //String to determine how this dot is updated\n        };\n\n        //randomly set the x and y coordinates\n        dot = resetLocation(dot);\n\n        //For the same && random position RDK type\n        if (RDK == 1) {\n          //For coherent dots\n          if (i < nCoherentDots) {\n            dot = setvxvy(dot); // Set dot.vx and dot.vy\n            dot.updateType = \"constant direction\";\n          }\n          //For opposite coherent dots\n          else if (i >= nCoherentDots && i < nCoherentDots + nOppositeCoherentDots) {\n            dot = setvxvy(dot); // Set dot.vx and dot.vy\n            dot.updateType = \"opposite direction\";\n          }\n          //For incoherent dots\n          else {\n            dot.updateType = \"random position\";\n          }\n        } //End of RDK==1\n\n        //For the same && random walk RDK type\n        if (RDK == 2) {\n          //For coherent dots\n          if (i < nCoherentDots) {\n            dot = setvxvy(dot); // Set dot.vx and dot.vy\n            dot.updateType = \"constant direction\";\n          }\n          //For opposite coherent dots\n          else if (i >= nCoherentDots && i < nCoherentDots + nOppositeCoherentDots) {\n            dot = setvxvy(dot); // Set dot.vx and dot.vy\n            dot.updateType = \"opposite direction\";\n          }\n          //For incoherent dots\n          else {\n            dot.updateType = \"random walk\";\n          }\n        } //End of RDK==2\n\n        //For the same && random direction RDK type\n        if (RDK == 3) {\n          //For coherent dots\n          if (i < nCoherentDots) {\n            dot = setvxvy(dot); // Set dot.vx and dot.vy\n            dot.updateType = \"constant direction\";\n          }\n          //For opposite coherent dots\n          else if (i >= nCoherentDots && i < nCoherentDots + nOppositeCoherentDots) {\n            dot = setvxvy(dot); // Set dot.vx and dot.vy\n            dot.updateType = \"opposite direction\";\n          }\n          //For incoherent dots\n          else {\n            setvx2vy2(dot); // Set dot.vx2 and dot.vy2\n            dot.updateType = \"random direction\";\n          }\n        } //End of RDK==3\n\n        //For the different && random position RDK type\n        if (RDK == 4) {\n          //For all dots\n          dot = setvxvy(dot); // Set dot.vx and dot.vy\n          dot.updateType = \"constant direction or opposite direction or random position\";\n        } //End of RDK==4\n\n        //For the different && random walk RDK type\n        if (RDK == 5) {\n          //For all dots\n          dot = setvxvy(dot); // Set dot.vx and dot.vy\n          dot.updateType = \"constant direction or opposite direction or random walk\";\n        } //End of RDK==5\n\n        //For the different && random direction RDK type\n        if (RDK == 6) {\n          //For all dots\n          dot = setvxvy(dot); // Set dot.vx and dot.vy\n          //Each dot will have its own alternate direction of motion\n          setvx2vy2(dot); // Set dot.vx2 and dot.vy2\n          dot.updateType = \"constant direction or opposite direction or random direction\";\n        } //End of RDK==6\n\n        tempArray.push(dot);\n      } //End of for loop\n      return tempArray;\n    }\n\n    //Function to update all the dots all the apertures and then draw them\n    function updateAndDraw() {\n      //Three for loops that do things in sequence: clear, update, and draw dots.\n\n      // Clear all the current dots\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Update all the relevant dots\n      for (currentApertureNumber = 0; currentApertureNumber < nApertures; currentApertureNumber++) {\n        //Initialize the variables for each parameter\n        initializeCurrentApertureParameters(currentApertureNumber);\n\n        //Update the dots\n        updateDots();\n      }\n\n      // Draw all the relevant dots on the canvas\n      for (currentApertureNumber = 0; currentApertureNumber < nApertures; currentApertureNumber++) {\n        //Initialize the variables for each parameter\n        initializeCurrentApertureParameters(currentApertureNumber);\n\n        //Draw on the canvas\n        draw();\n      }\n      //Draw the fixation cross if we want it\n      if (fixationCross === true) {\n        //Horizontal line\n        ctx.beginPath();\n        ctx.lineWidth = fixationCrossThickness;\n        ctx.moveTo(canvasWidth / 2 - fixationCrossWidth, canvasHeight / 2);\n        ctx.lineTo(canvasWidth / 2 + fixationCrossWidth, canvasHeight / 2);\n\n        //Vertical line\n        ctx.moveTo(canvasWidth / 2, canvasHeight / 2 - fixationCrossHeight);\n        ctx.lineTo(canvasWidth / 2, canvasHeight / 2 + fixationCrossHeight);\n        ctx.strokeStyle = fixationCrossColor;\n        ctx.stroke();\n      }\n    }\n\n    //Draw the dots on the canvas after they're updated\n    function draw() {\n      //Load in the current set of dot array for easy handling\n      const dotArray = dotArray2d[currentSetArray[currentApertureNumber]];\n\n      let drawFn;\n      let dot_size;\n      if (dotShape == \"square\") {\n        drawFn = squareFn;\n        dot_size = dotSideLength * 0.5;\n      } else {\n        drawFn = circleFn;\n        dot_size = dotRadius;\n      }\n\n      //Loop through the dots one by one and draw them\n      ctx.fillStyle = dotColor;\n      ctx.beginPath();\n      for (let i = 0; i < nDots; i++) {\n        const dot = dotArray[i];\n        ctx.moveTo(dot.x + dot_size, dot.y);\n        drawFn(dot.x, dot.y, dot_size);\n      }\n      ctx.fill();\n\n      //Draw the border if we want it\n      if (border === true) {\n        //For circle and ellipse\n        if (apertureType === 1 || apertureType === 2) {\n          ctx.lineWidth = borderThickness;\n          ctx.strokeStyle = borderColor;\n          ctx.beginPath();\n          ctx.ellipse(\n            apertureCenterX,\n            apertureCenterY,\n            horizontalAxis + borderThickness / 2,\n            verticalAxis + borderThickness / 2,\n            0,\n            0,\n            pi2\n          );\n          ctx.stroke();\n        } //End of if circle or ellipse\n\n        //For square and rectangle\n        if (apertureType === 3 || apertureType === 4) {\n          ctx.lineWidth = borderThickness;\n          ctx.strokeStyle = borderColor;\n          ctx.strokeRect(\n            apertureCenterX - horizontalAxis - borderThickness / 2,\n            apertureCenterY - verticalAxis - borderThickness / 2,\n            horizontalAxis * 2 + borderThickness,\n            verticalAxis * 2 + borderThickness\n          );\n        } //End of if square or\n      } //End of if border === true\n    } //End of draw\n\n    //Update the dots with their new location\n    function updateDots() {\n      //Cycle through to the next set of dots\n      if (currentSetArray[currentApertureNumber] == nSets - 1) {\n        currentSetArray[currentApertureNumber] = 0;\n      } else {\n        currentSetArray[currentApertureNumber] = currentSetArray[currentApertureNumber] + 1;\n      }\n\n      //Load in the current set of dot array for easy handling\n      var dotArray = dotArray2d[currentSetArray[currentApertureNumber]];\n\n      //Loop through the dots one by one and update them accordingly\n      for (var i = 0; i < nDots; i++) {\n        var dot = dotArray[i]; //Load the current dot into the variable for easy handling\n\n        //Generate a random value\n        var randomValue = Math.random();\n\n        //Update based on the dot's update type\n        if (dot.updateType == \"constant direction\") {\n          dot = constantDirectionUpdate(dot);\n        } else if (dot.updateType == \"opposite direction\") {\n          dot = oppositeDirectionUpdate(dot);\n        } else if (dot.updateType == \"random position\") {\n          dot = resetLocation(dot);\n        } else if (dot.updateType == \"random walk\") {\n          dot = randomWalkUpdate(dot);\n        } else if (dot.updateType == \"random direction\") {\n          dot = randomDirectionUpdate(dot);\n        } else if (\n          dot.updateType == \"constant direction or opposite direction or random position\"\n        ) {\n          //Randomly select if the dot goes in a constant direction or random position, weighted based on the coherence level\n          if (randomValue < coherence) {\n            dot = constantDirectionUpdate(dot);\n          } else if (randomValue >= coherence && randomValue < coherence + oppositeCoherence) {\n            dot = oppositeDirectionUpdate(dot);\n          } else {\n            dot = resetLocation(dot);\n          }\n        } else if (dot.updateType == \"constant direction or opposite direction or random walk\") {\n          //Randomly select if the dot goes in a constant direction or random walk, weighted based on the coherence level\n          if (randomValue < coherence) {\n            dot = constantDirectionUpdate(dot);\n          } else if (randomValue >= coherence && randomValue < coherence + oppositeCoherence) {\n            dot = oppositeDirectionUpdate(dot);\n          } else {\n            dot = randomWalkUpdate(dot);\n          }\n        } else if (\n          dot.updateType == \"constant direction or opposite direction or random direction\"\n        ) {\n          //Randomly select if the dot goes in a constant direction or random direction, weighted based on the coherence level\n          if (randomValue < coherence) {\n            dot = constantDirectionUpdate(dot);\n          } else if (randomValue >= coherence && randomValue < coherence + oppositeCoherence) {\n            dot = oppositeDirectionUpdate(dot);\n          } else {\n            dot = randomDirectionUpdate(dot);\n          }\n        } //End of if dot.updateType == ...\n\n        //Increment the life count\n        dot.lifeCount++;\n\n        //Check if out of bounds or if life ended\n        if (lifeEnded(dot)) {\n          dot = resetLocation(dot);\n        }\n\n        //If it goes out of bounds, do what is necessary (reinsert randomly or reinsert on the opposite edge) based on the parameter chosen\n        if (outOfBounds(dot)) {\n          switch (reinsertType) {\n            case 1:\n              dot = resetLocation(dot);\n              break;\n            case 2:\n              dot = reinsertOnOppositeEdge(dot);\n              break;\n          } //End of switch statement\n        } //End of if\n      } //End of for loop\n    } //End of updateDots function\n\n    //Function to check if dot life has ended\n    function lifeEnded(dot) {\n      //If we want infinite dot life\n      if (dotLife < 0) {\n        dot.lifeCount = 0; //resetting to zero to save memory. Otherwise it might increment to huge numbers.\n        return false;\n      }\n      //Else if the dot's life has reached its end\n      else if (dot.lifeCount >= dotLife) {\n        dot.lifeCount = 0;\n        return true;\n      }\n      //Else the dot's life has not reached its end\n      else {\n        return false;\n      }\n    }\n\n    //Function to check if dot is out of bounds\n    //@ts-expect-error \"not all code paths return a value\"\n    function outOfBounds(dot) {\n      //For circle and ellipse\n      if (apertureType == 1 || apertureType == 2) {\n        if (\n          dot.x < xValueNegative(dot.y) ||\n          dot.x > xValuePositive(dot.y) ||\n          dot.y < yValueNegative(dot.x) ||\n          dot.y > yValuePositive(dot.x)\n        ) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n      //For square and rectangle\n      if (apertureType == 3 || apertureType == 4) {\n        if (\n          dot.x < apertureCenterX - horizontalAxis ||\n          dot.x > apertureCenterX + horizontalAxis ||\n          dot.y < apertureCenterY - verticalAxis ||\n          dot.y > apertureCenterY + verticalAxis\n        ) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    }\n\n    //Set the vx and vy for the dot to the coherent jump sizes of the X and Y directions\n    function setvxvy(dot) {\n      dot.vx = coherentJumpSizeX;\n      dot.vy = coherentJumpSizeY;\n      return dot;\n    }\n\n    //Set the vx2 and vy2 based on a random angle\n    function setvx2vy2(dot) {\n      //Generate a random angle of movement\n      var theta = randomNumberBetween(-Math.PI, Math.PI);\n      //Update properties vx2 and vy2 with the alternate directions\n      dot.vx2 = Math.cos(theta) * moveDistance;\n      dot.vy2 = -Math.sin(theta) * moveDistance;\n      return dot;\n    }\n\n    //Updates the x and y coordinates by moving it in the x and y coherent directions\n    function constantDirectionUpdate(dot) {\n      dot.x += dot.vx;\n      dot.y += dot.vy;\n      dot.latestXMove = dot.vx;\n      dot.latestYMove = dot.vy;\n      return dot;\n    }\n\n    //Updates the x and y coordinates by moving it in the opposite x and y coherent directions\n    function oppositeDirectionUpdate(dot) {\n      dot.x -= dot.vx;\n      dot.y -= dot.vy;\n      dot.latestXMove = -dot.vx;\n      dot.latestYMove = -dot.vy;\n      return dot;\n    }\n\n    //Creates a new angle to move towards and updates the x and y coordinates\n    function randomWalkUpdate(dot) {\n      //Generate a random angle of movement\n      var theta = randomNumberBetween(-Math.PI, Math.PI);\n      //Generate the movement from the angle\n      dot.latestXMove = Math.cos(theta) * moveDistance;\n      dot.latestYMove = -Math.sin(theta) * moveDistance;\n      //Update x and y coordinates with the new location\n      dot.x += dot.latestXMove;\n      dot.y += dot.latestYMove;\n      return dot;\n    }\n\n    //Updates the x and y coordinates with the alternative move direction\n    function randomDirectionUpdate(dot) {\n      dot.x += dot.vx2;\n      dot.y += dot.vy2;\n      dot.latestXMove = dot.vx2;\n      dot.latestYMove = dot.vy2;\n      return dot;\n    }\n\n    //Calculates a random position on the opposite edge to reinsert the dot\n    function reinsertOnOppositeEdge(dot) {\n      //If it is a circle or ellipse\n      if (apertureType == 1 || apertureType == 2) {\n        //Bring the dot back into the aperture by moving back one step\n        dot.x -= dot.latestXMove;\n        dot.y -= dot.latestYMove;\n\n        //Move the dot to the position relative to the origin to be reflected about the origin\n        dot.x -= apertureCenterX;\n        dot.y -= apertureCenterY;\n\n        //Reflect the dot about the origin\n        dot.x = -dot.x;\n        dot.y = -dot.y;\n\n        //Move the dot back to the center of the screen\n        dot.x += apertureCenterX;\n        dot.y += apertureCenterY;\n      } //End of if apertureType == 1 | == 2\n\n      //If it is a square or rectangle, re-insert on one of the opposite edges\n      if (apertureType == 3 || apertureType == 4) {\n        /** The formula for calculating whether a dot appears from the vertical edge (left or right edges) is dependent on the direction of the dot and the ratio of the vertical and horizontal edge lengths.\n          E.g.  \n          Aperture is 100 px high and 200px wide\n          Dot is moving 3 px in x direction and 4px in y direction\n          Weight on vertical edge (sides)           = (100/(100+200)) * (|3| / (|3| + |4|)) = 1/7\n          Weight on horizontal edge (top or bottom) = (200/(100+200)) * (|4| / (|3| + |4|)) = 8/21\n        \n          The weights above are the ratios to one another.\n          E.g. (cont.)\n          Ratio (vertical edge : horizontal edge) == (1/7 : 8/21)\n          Total probability space = 1/7 + 8/21 = 11/21\n          Probability that dot appears on vertical edge   = (1/7)/(11/21) = 3/11\n          Probability that dot appears on horizontal edge = (8/21)/(11/21) = 8/11\n          */\n\n        //Get the absolute values of the latest X and Y moves and store them in variables for easy handling.\n        var absX = Math.abs(dot.latestXMove);\n        var absY = Math.abs(dot.latestYMove);\n        //Calculate the direction weights based on direction the dot was moving\n        var weightInXDirection = absX / (absX + absY);\n        var weightInYDirection = absY / (absX + absY);\n        //Calculate the weight of the edge the dot should appear from, based on direction of dot and ratio of the aperture edges\n        var weightOnVerticalEdge =\n          (verticalAxis / (verticalAxis + horizontalAxis)) * weightInXDirection;\n        var weightOnHorizontalEdge =\n          (horizontalAxis / (verticalAxis + horizontalAxis)) * weightInYDirection;\n\n        //Generate a bounded random number to determine if the dot should appear on the vertical edge or the horizontal edge\n        if (\n          weightOnVerticalEdge >\n          (weightOnHorizontalEdge + weightOnVerticalEdge) * Math.random()\n        ) {\n          //If yes, appear on the left or right edge (vertical edge)\n          if (dot.latestXMove < 0) {\n            //If dots move left, appear on right edge\n            dot.x = apertureCenterX + horizontalAxis;\n            dot.y = randomNumberBetween(\n              apertureCenterY - verticalAxis,\n              apertureCenterY + verticalAxis\n            );\n          } else {\n            //Else dots move right, so they should appear on the left edge\n            dot.x = apertureCenterX - horizontalAxis;\n            dot.y = randomNumberBetween(\n              apertureCenterY - verticalAxis,\n              apertureCenterY + verticalAxis\n            );\n          }\n        } else {\n          //Else appear on the top or bottom edge (horizontal edge)\n          if (dot.latestYMove < 0) {\n            //If dots move upwards, then appear on bottom edge\n            dot.y = apertureCenterY + verticalAxis;\n            dot.x = randomNumberBetween(\n              apertureCenterX - horizontalAxis,\n              apertureCenterX + horizontalAxis\n            );\n          } else {\n            //If dots move downwards, then appear on top edge\n            dot.y = apertureCenterY - verticalAxis;\n            dot.x = randomNumberBetween(\n              apertureCenterX - horizontalAxis,\n              apertureCenterX + horizontalAxis\n            );\n          }\n        }\n      } //End of apertureType == 3\n      return dot;\n    } //End of reinsertOnOppositeEdge\n\n    //Calculate the POSITIVE y value of a point on the edge of the ellipse given an x-value\n    function yValuePositive(x: number) {\n      x = x - apertureCenterX; //Bring it back to the (0,0) center to calculate accurately (ignore the y-coordinate because it is not necessary for calculation)\n      return (\n        verticalAxis * Math.sqrt(1 - Math.pow(x, 2) / Math.pow(horizontalAxis, 2)) + apertureCenterY\n      ); //Calculated the positive y value and added apertureCenterY to recenter it on the screen\n    }\n\n    //Calculate the NEGATIVE y value of a point on the edge of the ellipse given an x-value\n    function yValueNegative(x: number) {\n      x = x - apertureCenterX; //Bring it back to the (0,0) center to calculate accurately (ignore the y-coordinate because it is not necessary for calculation)\n      return (\n        -verticalAxis * Math.sqrt(1 - Math.pow(x, 2) / Math.pow(horizontalAxis, 2)) +\n        apertureCenterY\n      ); //Calculated the negative y value and added apertureCenterY to recenter it on the screen\n    }\n\n    //Calculate the POSITIVE x value of a point on the edge of the ellipse given a y-value\n    function xValuePositive(y: number) {\n      y = y - apertureCenterY; //Bring it back to the (0,0) center to calculate accurately (ignore the x-coordinate because it is not necessary for calculation)\n      return (\n        horizontalAxis * Math.sqrt(1 - Math.pow(y, 2) / Math.pow(verticalAxis, 2)) + apertureCenterX\n      ); //Calculated the positive x value and added apertureCenterX to recenter it on the screen\n    }\n\n    //Calculate the NEGATIVE x value of a point on the edge of the ellipse given a y-value\n    function xValueNegative(y: number) {\n      y = y - apertureCenterY; //Bring it back to the (0,0) center to calculate accurately (ignore the x-coordinate because it is not necessary for calculation)\n      return (\n        -horizontalAxis * Math.sqrt(1 - Math.pow(y, 2) / Math.pow(verticalAxis, 2)) +\n        apertureCenterX\n      ); //Calculated the negative x value and added apertureCenterX to recenter it on the screen\n    }\n\n    //Calculate a random x and y coordinate in the ellipse\n    function resetLocation(dot) {\n      //For circle and ellipse\n      if (apertureType == 1 || apertureType == 2) {\n        var phi = randomNumberBetween(-Math.PI, Math.PI);\n        var rho = Math.random();\n\n        var x = Math.sqrt(rho) * Math.cos(phi);\n        var y = Math.sqrt(rho) * Math.sin(phi);\n\n        x = x * horizontalAxis + apertureCenterX;\n        y = y * verticalAxis + apertureCenterY;\n\n        dot.x = x;\n        dot.y = y;\n      }\n      //For square and rectangle\n      else if (apertureType == 3 || apertureType == 4) {\n        dot.x = randomNumberBetween(\n          apertureCenterX - horizontalAxis,\n          apertureCenterX + horizontalAxis\n        ); //Between the left and right edges of the square / rectangle\n        dot.y = randomNumberBetween(apertureCenterY - verticalAxis, apertureCenterY + verticalAxis); //Between the top and bottom edges of the square / rectangle\n      }\n\n      return dot;\n    }\n\n    //Generates a random number (with decimals) between 2 values\n    function randomNumberBetween(lowerBound, upperBound) {\n      return lowerBound + Math.random() * (upperBound - lowerBound);\n    }\n\n    //Function to make the dots move on the canvas\n    function animateDotMotion() {\n      //frameRequestID saves a long integer that is the ID of this frame request. The ID is then used to terminate the request below.\n      var frameRequestID = window.requestAnimationFrame(animate);\n\n      //Start to listen to subject's key responses\n      startKeyboardListener();\n\n      //Delare a timestamp\n      var previousTimestamp;\n\n      function animate() {\n        //If stopping condition has been reached, then stop the animation\n        if (stopDotMotion) {\n          window.cancelAnimationFrame(frameRequestID); //Cancels the frame request\n        }\n        //Else continue with another frame request\n        else {\n          frameRequestID = window.requestAnimationFrame(animate); //Calls for another frame request\n\n          //If the timer has not been started and it is set, then start the timer\n          if (!timerHasStarted && trial_duration > 0) {\n            //If the trial duration is set, then set a timer to count down and call the end_trial function when the time is up\n            //(If the subject did not press a valid keyboard response within the trial duration, then this will end the trial)\n            timeoutID = window.setTimeout(end_trial, trial_duration); //This timeoutID is then used to cancel the timeout should the subject press a valid key\n            //The timer has started, so we set the variable to true so it does not start more timers\n            timerHasStarted = true;\n          }\n\n          updateAndDraw(); //Update and draw each of the dots in their respective apertures\n\n          //If this is before the first frame, then start the timestamp\n          if (previousTimestamp === undefined) {\n            previousTimestamp = performance.now();\n          }\n          //Else calculate the time and push it into the array\n          else {\n            var currentTimeStamp = performance.now(); //Variable to hold current timestamp\n            (frameRate as number[]).push(Math.round(currentTimeStamp - previousTimestamp)); //Push the interval into the frameRate array\n            previousTimestamp = currentTimeStamp; //Reset the timestamp\n          }\n        }\n      }\n    }\n\n    //----RDK Functions End----\n\n    //----General Functions Begin//----\n\n    //Function to assign the default values for the staircase parameters\n    function assignParameterValue(argument, defaultValue) {\n      return typeof argument !== \"undefined\" ? argument : defaultValue;\n    }\n\n    //----General Functions End//----\n\n    //-------------------------------------\n    //-----------FUNCTIONS END-------------\n    //-------------------------------------\n  }\n}\n\nexport default RdkPlugin;\n"],"names":["info","name","parameters","choices","type","ParameterType","KEYS","pretty_name","default","correct_choice","undefined","trial_duration","INT","response_ends_trial","BOOL","number_of_apertures","number_of_dots","number_of_sets","coherent_direction","coherence","FLOAT","opposite_coherence","dot_radius","dot_side_length","dot_life","move_distance","aperture_width","aperture_height","dot_color","STRING","dot_shape","background_color","RDK_type","aperture_type","reinsert_type","aperture_center_x","window","innerWidth","aperture_center_y","innerHeight","fixation_cross","fixation_cross_width","fixation_cross_height","fixation_cross_color","fixation_cross_thickness","border","border_thickness","border_color","RdkPlugin","jsPsych","_classCallCheck","this","key","value","display_element","trial","_this","assignParameterValue","apertureType","nApertures","nDots","nSets","coherentDirection","oppositeCoherence","dotRadius","dotSideLength","dotLife","moveDistance","apertureWidth","apertureHeight","dotColor","backgroundColor","apertureCenterX","apertureCenterY","RDK","dotShape","reinsertType","fixationCross","fixationCrossWidth","fixationCrossHeight","fixationCrossColor","fixationCrossThickness","borderThickness","borderColor","canvas","document","createElement","appendChild","body","getElementsByClassName","originalMargin","style","margin","originalPadding","padding","originalBackgroundColor","position","top","left","currentApertureNumber","ctx","getContext","canvasWidth","width","canvasHeight","height","nDotsArray","nSetsArray","coherentDirectionArray","coherenceArray","oppositeCoherenceArray","dotRadiusArray","dotSideLengthArray","dotLifeArray","moveDistanceArray","apertureWidthArray","apertureHeightArray","dotColorArray","dotShapeArray","apertureCenterXArray","apertureCenterYArray","RDKArray","apertureTypeArray","reinsertTypeArray","fixationCrossArray","fixationCrossWidthArray","fixationCrossHeightArray","fixationCrossColorArray","fixationCrossThicknessArray","borderArray","borderThicknessArray","borderColorArray","horizontalAxis","verticalAxis","coherentJumpSizeX","coherentJumpSizeY","nCoherentDots","nOppositeCoherentDots","dotArray2d","currentSetArray","dotArray3d","setParameter","initializeCurrentApertureParameters","push","makeDotArray2d","setUpMultipleApertures","timeoutID","keyboardListener","previousTimestamp","frameRequestID","stopDotMotion","timerHasStarted","response","rt","frameRate","numberOfFrames","pi2","Math","PI","circleFn","x","y","rad","arc","squareFn","half_len","len","rect","end_trial","length","frameRateArray","reduce","total","current","pluginAPI","cancelKeyboardResponse","trial_data","correct","correctOrNot","frame_rate","frame_rate_array","number_of_frames","canvas_width","canvas_height","innerHTML","finishTrial","after_response","clearTimeout","requestAnimationFrame","animate","cancelAnimationFrame","setTimeout","clearRect","updateDots","draw","beginPath","lineWidth","moveTo","lineTo","strokeStyle","stroke","updateAndDraw","performance","now","currentTimeStamp","round","getKeyboardResponse","callback_function","valid_responses","rt_method","persist","allow_held_key","constructor","Array","String","every","compareKeys","console","error","originalVariable","tempArray","i","angleInRadians","cos","calculateCoherentJumpSizeX","sin","calculateCoherentJumpSizeY","makeDotArray","dot","vx","vy","vx2","vy2","latestXMove","latestYMove","lifeCount","floor","randomNumberBetween","updateType","resetLocation","setvxvy","setvx2vy2","drawFn","dot_size","dotArray","fillStyle","fill","ellipse","strokeRect","randomValue","random","constantDirectionUpdate","oppositeDirectionUpdate","randomWalkUpdate","randomDirectionUpdate","lifeEnded","outOfBounds","reinsertOnOppositeEdge","sqrt","pow","xValuePositive","yValuePositive","theta","absX","abs","absY","weightOnVerticalEdge","phi","rho","lowerBound","upperBound","argument","defaultValue"],"mappings":"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"}